<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Pose Coach</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #0066ff;
            --secondary: #00cc99;
            --dark: #121212;
            --light: #f8f9fa;
            --gray: #2a2a2a;
            --gradient: linear-gradient(135deg, var(--primary), var(--secondary));
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--dark);
            color: var(--light);
            line-height: 1.6;
            overflow-x: hidden;
        }
        
        h1, h2, h3, h4, h5 {
            font-family: 'Montserrat', sans-serif;
            font-weight: 700;
        }

        /* Logo & Header */
        header {
            background-color: rgba(18, 18, 18, 0.95);
            width: 100%;
            z-index: 1000;
            padding: 1.2rem 0;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            margin-bottom: 2rem;
            display: flex;
            justify-content: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--light);
        }
        
        .logo-img {
            width: 70px;
            height: 70px;
            border-radius: 50%; /* For a rounded logo */
            object-fit: cover;
        }

        .container {
            width: 90%;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .page-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            min-height: 100vh;
            justify-content: center;
        }

        .ai-container {
            width: 100%;
            max-width: 900px;
            background: var(--gray);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            margin-bottom: 2rem;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 Aspect Ratio (480 / 640) */
            background-color: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 2rem;
        }
        
        .video-container video, .video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        .stat-card {
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-card h3 {
            font-family: 'Montserrat', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--gradient);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .stat-card p {
            font-size: 1.1rem;
            color: #ccc;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 9999px;
            overflow: hidden;
            margin-top: 1rem;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--secondary);
            transition: width 0.3s ease-in-out;
        }

        .btn-start {
            background: var(--gradient);
            color: white;
            border: none;
            padding: 1rem 2.5rem;
            border-radius: 30px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-start:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 102, 255, 0.3);
        }
        
        @media (max-width: 600px) {
            .nav-links { display: none; }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="logo.png" alt="Aura Logo" class="logo-img">
        </div>
    </header>

    <div class="page-container container">
        <div class="ai-container">
            <h1 style="font-size: 2.5rem; text-align: center; margin-bottom: 1rem;">AI Pose Coach</h1>
            <p style="text-align: center; margin-bottom: 2rem; color: #ccc;">Get real-time feedback for your workout.</p>

            <div class="video-container">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-center">
                <div class="stat-card">
                    <h3 id="counter-display">Reps: 0</h3>
                    <p>Repetitions</p>
                </div>
                <div class="stat-card">
                    <h3 id="instruction-message">Start your camera.</h3>
                    <p>Feedback</p>
                </div>
            </div>

            <div class="w-full flex justify-center mt-6">
                <select id="exercise-select" style="background-color: var(--gray); color: var(--light);" class="rounded-full px-5 py-3 border-none focus:outline-none focus:ring-2 focus:ring-primary">
                    <option value="squats">Squats</option>
                    <option value="pushups">Push-ups</option>
                    <option value="plank">Plank</option>
                </select>
            </div>

            <div class="w-full flex flex-col items-center mt-6">
                <button id="start-button" class="btn-start">
                    Start
                </button>
            </div>

            <div id="progress-container" class="progress-bar-container" style="display: none;">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
        </div>
    </div>
    
    <script>
        // HTML elements ko variables mein store karein
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const counterDisplay = document.getElementById('counter-display');
        const instructionMessage = document.getElementById('instruction-message');
        const exerciseSelect = document.getElementById('exercise-select');
        const progressBar = document.getElementById('progress-bar');
        const progressContainer = document.getElementById('progress-bar-container');

        // Global variables
        let pose;
        let videoWidth, videoHeight;
        let reps = 0;
        let squatState = 'up';
        let pushupState = 'up';
        let isStarted = false;
        let plankStartTime = 0;
        let timerInterval;
        let lastInstructionTime = 0;
        const instructionCooldown = 3000; // 3 seconds cooldown for voice instructions
        let currentInstruction = '';

        // Voice synthesis setup
        const synth = window.speechSynthesis;
        let isSpeaking = false;

        const speak = (text) => {
            if (isSpeaking || Date.now() - lastInstructionTime < instructionCooldown || currentInstruction === text) {
                return;
            }
            isSpeaking = true;
            lastInstructionTime = Date.now();
            currentInstruction = text;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            utterance.onend = () => {
                isSpeaking = false;
                currentInstruction = '';
            };
            synth.speak(utterance);
        };
        
        // Camera setup function
        const setupCamera = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    'audio': false,
                    'video': {
                        facingMode: 'user',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    },
                });
                video.srcObject = stream;
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve(video);
                    };
                });
            } catch (error) {
                console.error('Problem starting camera:', error);
                instructionMessage.textContent = 'Could not start the camera. Please grant permission.';
            }
        };
        
        // MediaPipe pose model load function
        const loadMediaPipe = () => {
            instructionMessage.textContent = 'AI model is loading...';
            pose = new Pose({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                }
            });
            
            pose.setOptions({
                modelComplexity: 2, // High accuracy model
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            pose.onResults(onResults);
            instructionMessage.textContent = 'AI model loaded.';
        };

        // Main detection loop with MediaPipe
        const startDetection = async () => {
            const videoElem = await setupCamera();
            if (videoElem) {
                videoWidth = videoElem.videoWidth;
                videoHeight = videoElem.videoHeight;
                canvas.width = videoWidth;
                canvas.height = videoHeight;
                
                const camera = new Camera(video, {
                    onFrame: async () => {
                        if (isStarted) {
                            await pose.send({ image: video });
                        }
                    },
                    width: videoWidth,
                    height: videoHeight
                });
                camera.start();
                instructionMessage.textContent = `Get ready to perform ${exerciseSelect.value}.`;
                speak(`Welcome! Get ready to perform ${exerciseSelect.value}. Please stand sideways to the camera so I can see your body clearly.`);
            }
        };

        // MediaPipe onResults callback
        const onResults = (results) => {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            
            if (results.poseLandmarks) {
                const landmarks = results.poseLandmarks.map(l => ({
                    x: l.x * videoWidth,
                    y: l.y * videoHeight,
                    z: l.z,
                    visibility: l.visibility
                }));
                
                const leftSideVisibility = landmarks[23].visibility + landmarks[25].visibility + landmarks[27].visibility;
                const rightSideVisibility = landmarks[24].visibility + landmarks[26].visibility + landmarks[28].visibility;
                let orientation = '';
                if (leftSideVisibility > rightSideVisibility + 0.5) {
                    orientation = 'right_facing';
                } else if (rightSideVisibility > leftSideVisibility + 0.5) {
                    orientation = 'left_facing';
                } else {
                    orientation = 'frontal';
                }

                const formError = analyzePose(landmarks, orientation);
                const color = formError === null ? '#0f0' : '#f00';
                drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, { color: color, lineWidth: 5 });
                drawLandmarks(ctx, results.poseLandmarks, { color: color, lineWidth: 2, radius: 5 });
                
                if (formError !== null) {
                    instructionMessage.textContent = "Incorrect form: " + formError;
                    speak(formError);
                } else {
                    instructionMessage.textContent = "Correct form!";
                }
            }
            ctx.restore();
        };

        const getAngle = (a, b, c) => {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) {
                angle = 360 - angle;
            }
            return angle;
        };

        const analyzePose = (landmarks, orientation) => {
            if (orientation === 'frontal' || !isStarted) {
                return "Please stand sideways to the camera.";
            }
            
            const requiredVisibility = 0.7;
            const side_landmarks = orientation === 'left_facing' ? [12, 14, 16, 24, 26, 28] : [11, 13, 15, 23, 25, 27];
            const all_visible = side_landmarks.every(index => landmarks[index].visibility > requiredVisibility);
            if (!all_visible) {
                return "Make sure your full body is visible.";
            }

            switch(exerciseSelect.value) {
                case 'squats':
                    return analyzeSquats(landmarks, orientation);
                case 'pushups':
                    return analyzePushups(landmarks, orientation);
                case 'plank':
                    return analyzePlank(landmarks, orientation);
            }
            return null;
        };

        const analyzeSquats = (landmarks, orientation) => {
            const kneeAngle = orientation === 'left_facing' ? getAngle(landmarks[24], landmarks[26], landmarks[28]) : getAngle(landmarks[23], landmarks[25], landmarks[27]);
            const hipAngle = orientation === 'left_facing' ? getAngle(landmarks[12], landmarks[24], landmarks[26]) : getAngle(landmarks[11], landmarks[23], landmarks[25]);
            const torsoAngle = orientation === 'left_facing' ? getAngle(landmarks[14], landmarks[12], landmarks[24]) : getAngle(landmarks[13], landmarks[11], landmarks[23]);
            
            const upThreshold = 160; 
            const squatThreshold = 90;
            const torsoThreshold = 170;

            // Checking for correct form
            if (kneeAngle > upThreshold && hipAngle > upThreshold && squatState === 'up') {
                // Correct standing position, nothing to do here.
            } else if (kneeAngle > upThreshold && hipAngle > upThreshold && squatState === 'down') {
                reps++;
                counterDisplay.textContent = `Reps: ${reps}`;
                squatState = 'up';
                progressBar.style.width = `0%`;
                speak('Great! One rep completed. Well done!');
                return null;
            } else if (kneeAngle < upThreshold && hipAngle < upThreshold) {
                squatState = 'down';
                // Check for incorrect form during the squat
                if (kneeAngle < squatThreshold) {
                    // Correct depth, but still in the down phase
                    const progress = Math.min(100, Math.max(0, (upThreshold - kneeAngle) / (upThreshold - squatThreshold) * 100));
                    progressBar.style.width = `${progress}%`;
                    return null; // Correct form for this phase
                }
                if (torsoAngle < torsoThreshold) {
                    return "Keep your chest up!";
                }
                if (kneeAngle > 90) {
                    const progress = Math.min(100, Math.max(0, (upThreshold - kneeAngle) / (upThreshold - squatThreshold) * 100));
                    progressBar.style.width = `${progress}%`;
                    return "Go down a little lower!";
                }
            } else {
                return "Adjust your body position!";
            }
            return null;
        };

        const analyzePushups = (landmarks, orientation) => {
            const elbowAngle = orientation === 'left_facing' ? getAngle(landmarks[12], landmarks[14], landmarks[16]) : getAngle(landmarks[11], landmarks[13], landmarks[15]);
            const hipAngle = orientation === 'left_facing' ? getAngle(landmarks[12], landmarks[24], landmarks[28]) : getAngle(landmarks[11], landmarks[23], landmarks[27]);
            const bodyStraightness = Math.abs(landmarks[12].y - landmarks[24].y) < 50 && Math.abs(landmarks[24].y - landmarks[28].y) < 50;

            const upThreshold = 160;
            const downThreshold = 90;

            if (pushupState === 'up' && elbowAngle < upThreshold) {
                pushupState = 'down';
            }

            if (pushupState === 'down' && elbowAngle > downThreshold) {
                const progress = Math.min(100, Math.max(0, (upThreshold - elbowAngle) / (upThreshold - downThreshold) * 100));
                progressBar.style.width = `${progress}%`;
                if (!bodyStraightness) {
                    return "Keep your body in a straight line!";
                }
                return null; // Correct form for this phase
            } else if (pushupState === 'down' && elbowAngle < downThreshold) {
                if (!bodyStraightness) {
                    return "Keep your body in a straight line!";
                }
                if (hipAngle < 160) {
                    return "Hips are sagging! Raise them!";
                }
                return null; // Correct form for this phase
            }

            if (pushupState === 'down' && elbowAngle > upThreshold) {
                reps++;
                counterDisplay.textContent = `Reps: ${reps}`;
                pushupState = 'up';
                progressBar.style.width = `0%`;
                speak('Great! One rep completed. Well done!');
                return null;
            }
            
            progressBar.style.width = `0%`;
            return null;
        };
        
        const analyzePlank = (landmarks, orientation) => {
            const hipAngle = orientation === 'left_facing' ? getAngle(landmarks[12], landmarks[24], landmarks[28]) : getAngle(landmarks[11], landmarks[23], landmarks[27]);
            const bodyStraightness = Math.abs(landmarks[12].y - landmarks[24].y) < 50 && Math.abs(landmarks[24].y - landmarks[28].y) < 50;

            progressContainer.style.display = 'block';
            progressBar.style.width = '100%';

            if (hipAngle > 160 && hipAngle < 200 && bodyStraightness) {
                if (plankStartTime === 0) {
                    plankStartTime = Date.now();
                    timerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - plankStartTime) / 1000);
                        counterDisplay.textContent = `Time: ${elapsed}s`;
                    }, 1000);
                    speak('Perfect plank form! Hold it!');
                }
                return null;
            } else {
                clearInterval(timerInterval);
                plankStartTime = 0;
                if (hipAngle <= 160) {
                    return 'Hips are sagging. Raise your hips!';
                } else if (hipAngle >= 200) {
                    return 'Hips are too high. Lower your hips!';
                } else if (!bodyStraightness) {
                    return 'Keep your body in a straight line!';
                }
                return null;
            }
        };

        startButton.addEventListener('click', async () => {
            isStarted = !isStarted;
            if (isStarted) {
                startButton.textContent = 'Stop';
                reps = 0;
                plankStartTime = 0;
                clearInterval(timerInterval);
                counterDisplay.textContent = (exerciseSelect.value === 'plank') ? 'Time: 0s' : 'Reps: 0';
                instructionMessage.textContent = 'Camera is starting...';
                loadMediaPipe();
                await startDetection();
                if(exerciseSelect.value === 'plank') {
                    progressContainer.style.display = 'block';
                } else {
                    progressContainer.style.display = 'none';
                }
            } else {
                startButton.textContent = 'Start';
                instructionMessage.textContent = 'Camera is off.';
                clearInterval(timerInterval);
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                progressContainer.style.display = 'none';
            }
        });

        exerciseSelect.addEventListener('change', () => {
            reps = 0;
            squatState = 'up';
            pushupState = 'up';
            plankStartTime = 0;
            clearInterval(timerInterval);
            if(exerciseSelect.value === 'plank') {
                counterDisplay.textContent = 'Time: 0s';
                progressContainer.style.display = 'block';
            } else {
                counterDisplay.textContent = 'Reps: 0';
                progressContainer.style.display = 'none';
            }
            instructionMessage.textContent = `Get ready to perform ${exerciseSelect.value}.`;
        });
    </script>
</body>
</html>